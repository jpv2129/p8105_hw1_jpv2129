---
title: "p8105_hw1_jpv2129"
author: "Jake Vettoretti"
date: "2025-09-18"
output: github_document
---

## Problem 1

Loading the dataset
```{r}
library(tidyverse)
library(moderndive)
data("early_january_weather") #loads the dataset
```


Getting the number of rows/columns in the dataset and mean temp from the dataset.
```{r}
nrow(early_january_weather) #gets rows
ncol(early_january_weather) #gets columns
mean(with(early_january_weather, temp)) #calculating the mean temp
```

Dataset description:
There are 15 variables in the dataset.

The names of the variables are: origin, year, month, day, hour, temp, dewp, humid, wind_dir, wind_speed, wind_gust, 
precip, pressure, visib, and time_hour.

The important variables seem to be temp, dewp, humid, wind_dir, wind_speed, wind_gust, 
precip, pressure, and visib as these are the variables listed that mainly contribute to weather patterns.

There are 15 columns in the dataset and 358 rows (or observations).

The mean temp from the dataset is 39.58212 F.

Scatterplot:

```{r}
ggplot(early_january_weather, aes(x=time_hour,y=temp, color=humid)) + geom_point() #making the scatterplot with color points for humidity

ggsave("temp_vs_time_scatterplot.png") #saving scatterplot into project directory
```

Description of patterns in scatterplot:
The scatterplot of temperature vs. time shows a clear daily cycle: temperatures tend to rise during daytime and fall overnight. Higher humidity values are associated with cooler temperatures, while warmer periods tend to coincide with lower humidity. The points form smooth waves over time, reflecting the regular variation in weather across consecutive days. Specifically, we see temperature changes over time in January. Overall, temperatures fluctuate daily but gradually increase from early to mid-January, starting mostly between 25–40°F through Jan 7th and more frequently rising to 45–55°F closer to January 14. As for daily trends, temperatures rise during the day and fall during night time, which means that humidity is higher during the day as well.

Humidity increases with  warmer temperatures and spikes in mid-January when temperatures peak. Lower humidity values are more evenly spread and more common at cooler temperatures. 

## Problem 2

Creating the dataframe:

```{r}
problem2_df = #creating my own dataframe with conditions described.
  tibble(
    randsamp = rnorm(10), # random sample of size 10 from a standard Normal distribution
    logic = rnorm(10) > 0, # a logical vector indicating whether elements of the sample are greater than 0
    char = c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j"), # a character vector of length 10
    fac = factor(c("male", "male", "female", "female", "male", "female", "other", "other", "male", "female")) # a factor vector of length 10, with 3 different factor “levels”
  )

#taking means below
mean(problem2_df |>  pull(randsamp))    # works
mean(problem2_df |>  pull(logic))   # works
mean(problem2_df |>  pull(char))   # error 
mean(problem2_df |>  pull(fac))    # error 
```

Here, we see that only the means for our random sample and logic vector work, while the means for the character and factor do not work.
This is because the latter are not numerical or logic value and are character values.
Logic works because TRUE converts to 1 and FALSE converts to 0.

Now, convert variables to numeric values.

```{r}
# Convert to numeric by pulling from the tibble
logicnum <- as.numeric(problem2_df |> pull(logic))    # logical -> numeric (TRUE=1, FALSE=0)
charnum  <- as.numeric(problem2_df |> pull(char))  # character -> numeric, produces NA + warning
facnum   <- as.numeric(problem2_df |> pull(fac))    # factor -> numeric (uses internal integer codes)
```

```{r include=FALSE}
mean(logicnum) #works
mean(charnum) #error
mean(facnum)   #works
```


What happens, and why? Does this help explain what happens when you try to take the mean?

When converting variables with as.numeric(), logical values become 0 or 1, so the mean represents the proportion of TRUEs or 1s. Characters cannot be meaningfully coerced, so all values become NA and the mean fails. Factors are stored as integer codes, so a mean can be calculated, but it only reflects the arbitrary coding of categories rather than anything meaningful about the data.













